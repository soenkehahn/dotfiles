#!/usr/bin/env stack
{- stack script --resolver nightly-2020-08-01
  --package process
  --package shake
  --package unix
-}

{-# LANGUAGE ScopedTypeVariables #-}

import Development.Shake
import Control.Concurrent
import Control.Exception
import System.Process
import System.Posix.Signals
import System.Exit
import Control.Monad
import Data.Void
import Data.List

type ProcessPool = String -> [String] -> IO ()

setupProcessPool :: IO ProcessPool
setupProcessPool = do
  children <- newMVar []
  let terminateChildren = do
        modifyMVar_ children $ \ children -> do
          forM_ children $ \ (name, child) -> do
            putStrLn ("terminating: " ++ name)
            terminateProcess child
            waitForProcess child
          return []
        exitWith ExitSuccess
  installHandler sigINT (CatchOnce terminateChildren) Nothing
  return $ \ command args -> do
    (_, _, _, handle) <- createProcess (proc command args)
    modifyMVar_ children $ \ children -> return ((command, handle) : children)

main :: IO Void
main = do
  spawn <- setupProcessPool
  activateMonitor
  startJack spawn
  spawn "a2jmidid" ["-e"]
  spawn "touchscreen-instrument" []
  spawn "guitarix" []
  connectPorts $
    ((== "touchscreen-instrument:left-output"), "gx_head_amp:in_0") :
    (midiControllerPort, "touchscreen-instrument:controller") :
    (expressionPedalPort, "touchscreen-instrument:controller") :
    []

activateMonitor :: IO ()
activateMonitor = do
  cmd_ "xrandr --output eDP-1 --mode 2560x1440 --pos 0x0 --rotate normal --output DP-1 --off --output HDMI-1 --primary --mode 1920x1080 --pos 2560x360 --rotate normal --output DP-2 --off"

startJack spawn = do
  spawn "jackd" $ words "--sync --realtime -d alsa --rate 48000 --period 256"
  putStrLn "waiting..."
  cmd_ "jack_wait -w"
  putStrLn "done!"
  threadDelay 100000

midiControllerPort port =
  "a2j:WORLDE easy control [" `isPrefixOf` port &&
  "] (capture): WORLDE easy control MIDI 1" `isSuffixOf` port

expressionPedalPort port =
  "a2j:beat bars adapter [" `isPrefixOf` port &&
  "] (capture): beat bars adapter MIDI 1" `isSuffixOf` port

getPorts :: IO [String]
getPorts = do
  Stdout output <- cmd "jack_lsp"
  return $ lines output

tryConnect :: (String -> Bool) -> String -> IO ()
tryConnect from to = do
  ports <- getPorts
  case filter from ports of
    [from] -> do
      Exit _ <- cmd "jack_connect" [from, to]
      return ()
    _ -> return ()

connectPorts :: [(String -> Bool, String)] -> IO Void
connectPorts ports = do
  threadDelay 5000000
  forM_ ports $ \ (from, to) -> do
    tryConnect from to
  waitForever

waitForever :: IO Void
waitForever = do
  threadDelay 1000000000
  waitForever
