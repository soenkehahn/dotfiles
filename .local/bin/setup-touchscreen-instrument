#!/usr/bin/env stack
{- stack script --resolver nightly-2020-08-01
  --package getopt-generics
  --package process
  --package shake
  --package unix
-}

{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# OPTIONS_GHC -Wall -Wno-name-shadowing #-}

import Control.Concurrent
import Control.Monad
import Data.List
import Development.Shake
import System.Posix.Signals
import System.Process
import WithCli

data ProcessPool = ProcessPool {
  spawn :: String -> [String] -> IO (),
  waitUntilExit :: IO ()
}

setupProcessPool :: IO ProcessPool
setupProcessPool = do
  children <- newMVar []
  waiter <- newEmptyMVar
  let terminateChildren = do
        modifyMVar_ children $ \ children -> do
          forM_ children $ \ (name, child) -> do
            putStrLn ("terminating: " ++ name)
            terminateProcess child
            putStrLn ("waiting for: " ++ name)
            _ <- waitForProcess child
            putStrLn ("done waiting for: " ++ name)
          return []
        putMVar waiter ()
  _ <- installHandler sigINT (CatchOnce terminateChildren) Nothing
  return $ ProcessPool {
    spawn = \ command args -> do
      (_, _, _, handle) <- createProcess (proc command args)
      modifyMVar_ children $ \ children -> return ((command, handle) : children)
      _ <- forkIO $ do
        _ <- waitForProcess handle
        putStrLn (command ++ " is done")
        terminateChildren
      return (),
    waitUntilExit = do
      readMVar waiter
  }

data Args
  = Args {
    selfCheck :: Bool
  }
  deriving (Show, Generic, HasArguments)

main :: IO ()
main = withCli $ \ args -> do
  if selfCheck args
    then putStrLn "checked!"
    else do
      pool <- setupProcessPool
      activateMonitor
      startJack pool
      spawn pool "a2jmidid" ["-e"]
      spawn pool "touchscreen-instrument" []
      spawn pool "guitarix" []
      wait 5
      connectPorts
      waitUntilExit pool

activateMonitor :: IO ()
activateMonitor = do
  cmd_ "xrandr --output eDP-1 --mode 2560x1440 --pos 0x0 --rotate normal --output DP-1 --off --output HDMI-1 --primary --mode 1920x1080 --pos 2560x360 --rotate normal --output DP-2 --off"

startJack :: ProcessPool -> IO ()
startJack pool = do
  spawn pool "jackd" $ words "--sync --realtime -d alsa --rate 48000 --period 256"
  putStrLn "waiting..."
  cmd_ "jack_wait -w"
  putStrLn "done!"
  wait 0.1

connectPorts :: IO ()
connectPorts = do
  let midiControllerPort port =
        "a2j:WORLDE easy control [" `isPrefixOf` port &&
        "] (capture): WORLDE easy control MIDI 1" `isSuffixOf` port
      expressionPedalPort port =
        "a2j:beat bars adapter [" `isPrefixOf` port &&
        "] (capture): beat bars adapter MIDI 1" `isSuffixOf` port
      ports =
        ((== "touchscreen-instrument:left-output"), "gx_head_amp:in_0") :
        (midiControllerPort, "touchscreen-instrument:controller") :
        (expressionPedalPort, "touchscreen-instrument:controller") :
        []
  forM_ ports $ \ (from, to) -> do
    tryConnect from to

getPorts :: IO [String]
getPorts = do
  Stdout output <- cmd "jack_lsp"
  return $ lines output

tryConnect :: (String -> Bool) -> String -> IO ()
tryConnect from to = do
  ports <- getPorts
  case filter from ports of
    [from] -> do
      Exit _ <- cmd "jack_connect" [from, to]
      return ()
    _ -> return ()

wait :: Double -> IO ()
wait seconds = threadDelay $ round (seconds * 1000000)
