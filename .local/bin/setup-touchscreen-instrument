#!/usr/bin/env stack
{- stack script --resolver nightly-2020-08-01
  --package aeson
  --package explicit-exception
  --package getopt-generics
  --package jack
  --package process
  --package shake
  --package transformers
  --package uniplate
  --package unix
-}

{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# OPTIONS_GHC -Wall -Wno-name-shadowing #-}

import           Control.Concurrent
import           Control.Monad
import           Control.Monad.Exception.Synchronous
import           Control.Monad.Trans.Class (lift)
import qualified Data.Aeson as Aeson
import           Data.Data
import           Data.Generics.Uniplate.Data
import           Data.List
import           Development.Shake
import           Sound.JACK
import           Sound.JACK.Exception
import           System.Posix.Signals
import           System.Process
import           WithCli

data ProcessPool = ProcessPool {
  spawn :: String -> [String] -> IO (),
  exit :: IO (),
  waitUntilExit :: IO ()
}

setupProcessPool :: IO ProcessPool
setupProcessPool = do
  children <- newMVar []
  waiter <- newEmptyMVar
  let terminateChildren = do
        modifyMVar_ children $ \ children -> do
          forM_ children $ \ (name, child) -> do
            putStrLn ("terminating: " ++ name)
            terminateProcess child
            putStrLn ("waiting for: " ++ name)
            _ <- waitForProcess child
            putStrLn ("done waiting for: " ++ name)
          return []
        putMVar waiter ()
  _ <- installHandler sigINT (CatchOnce terminateChildren) Nothing
  return $ ProcessPool {
    spawn = \ command args -> do
      (_, _, _, handle) <- createProcess (proc command args)
      modifyMVar_ children $ \ children -> return ((command, handle) : children)
      _ <- forkIO $ do
        _ <- waitForProcess handle
        putStrLn (command ++ " is done")
        terminateChildren
      return (),
    exit = terminateChildren,
    waitUntilExit = do
      readMVar waiter
  }

data Args
  = Args {
    selfCheck :: Bool
  }
  deriving (Show, Generic, HasArguments)

main :: IO ()
main = withCli $ \ args -> do
  if selfCheck args
    then putStrLn "checked!"
    else do
      pool <- setupProcessPool
      activateMonitor
      startJack pool
      spawn pool "a2jmidid" ["-e"]
      startInstrument pool
      spawn pool "guitarix" []
      wait 5
      connectPorts pool
      waitUntilExit pool

activateMonitor :: IO ()
activateMonitor = do
  cmd_ "xrandr --output eDP-1 --mode 2560x1440 --pos 0x0 --rotate normal --output DP-1 --off --output HDMI-1 --primary --mode 1920x1080 --pos 2560x360 --rotate normal --output DP-2 --off"

startJack :: ProcessPool -> IO ()
startJack pool = do
  spawn pool "jackd" $ words "--sync --realtime -d alsa --rate 48000 --period 256 --nperiod 4"
  putStrLn "waiting..."
  cmd_ "jack_wait -w"
  putStrLn "done!"
  wait 0.1

startInstrument :: ProcessPool -> IO ()
startInstrument pool = do
  spawn pool "touchscreen-instrument" []
  waitForWindow
  moveToTouchscreen
  setFullscreen

waitForWindow :: IO ()
waitForWindow = do
  waitFor 100 doesWindowExist
  where
    doesWindowExist = do
      tree :: Tree <- cmdToJson "i3-msg -t get_tree"
      let windows :: [WindowProperties] = universeBi tree
      return $ any (\ window -> title window == "touchscreen-instrument") windows

cmdToJson :: (Aeson.FromJSON a) => String -> IO a
cmdToJson command = do
  Stdout json <- cmd command
  let Just result = Aeson.decode json
  return result

data Tree = Tree {
  nodes :: [Tree],
  window_properties :: Maybe WindowProperties
} deriving (Show, Generic, Aeson.FromJSON, Data)

data WindowProperties = WindowProperties {
  title :: String
} deriving (Show, Generic, Aeson.FromJSON, Data)

moveToTouchscreen :: IO ()
moveToTouchscreen = do
  touchscreenWorkspace <- getTouchscreenWorkspace
  cmd "i3-msg"
    ["[class=\"touchscreen-instrument\"] move workspace" ++
    name touchscreenWorkspace]
  where
    getTouchscreenWorkspace = do
      workspaces :: [Workspace] <- cmdToJson "i3-msg -t get_workspaces"
      return $ case filter isTouchscreenWorkspace workspaces of
        a : _ -> a
        [] -> error "moveToTouchscreen: workspace not found"
    isTouchscreenWorkspace workspace =
      output workspace == "HDMI-1" &&
      visible workspace

data Workspace = Workspace {
  name :: String,
  visible :: Bool,
  output :: String
} deriving (Show, Generic, Aeson.FromJSON, Data)

setFullscreen :: IO ()
setFullscreen = do
  cmd "i3-msg" ["[class=\"touchscreen-instrument\"] fullscreen toggle"]

connectPorts :: ProcessPool -> IO ()
connectPorts pool = do
  _ <- forkIO $ do
    result <- runExceptionalT $
      withClientDefault "setup-touchscreen-instrument" $ \ client -> lift $ do
        makeConnections client
        let loop :: [String] -> IO ()
            loop previousPorts = do
              ports <- getPorts client
              when (previousPorts /= ports) $ do
                print "port change detected"
                makeConnections client
              wait 1
              loop ports
        loop =<< getPorts client
    case result of
      Success () -> return ()
      Exception (e :: All) -> do
        putStrLn $ toStringWithHead e
        exit pool
  return ()

makeConnections :: Client -> IO ()
makeConnections client = do
  let midiControllerPort port =
        "a2j:WORLDE easy control [" `isPrefixOf` port &&
        "] (capture): WORLDE easy control MIDI 1" `isSuffixOf` port
      expressionPedalPort port =
        "a2j:beat bars adapter [" `isPrefixOf` port &&
        "] (capture): beat bars adapter MIDI 1" `isSuffixOf` port
      connections =
        ((== "touchscreen-instrument:left-output"), "gx_head_amp:in_0") :
        (midiControllerPort, "touchscreen-instrument:controller") :
        (expressionPedalPort, "touchscreen-instrument:controller") :
        []
  forM_ connections $ \ (from, to) -> do
    tryConnect client from to

tryConnect :: Client -> (String -> Bool) -> String -> IO ()
tryConnect client from to = do
  ports <- getPorts client
  case filter from ports of
    [from] -> do
      Exit _ <- cmd "jack_connect" [from, to]
      return ()
    _ -> return ()

wait :: Double -> IO ()
wait seconds = threadDelay $ round (seconds * 1000000)

waitFor :: Int -> IO Bool -> IO ()
waitFor n predicate = case n of
  0 -> error "waitFor: waited too often"
  n -> do
    done <- predicate
    when (not done) $ do
      wait 0.1
      waitFor (n - 1) predicate
