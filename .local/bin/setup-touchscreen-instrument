#!/usr/bin/env stack
{- stack script --resolver nightly-2020-08-01
  --package explicit-exception
  --package getopt-generics
  --package jack
  --package process
  --package shake
  --package transformers
  --package unix
-}

{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# OPTIONS_GHC -Wall -Wno-name-shadowing #-}

import Control.Concurrent
import Control.Monad
import Control.Monad.Exception.Synchronous
import Data.List
import Development.Shake
import Sound.JACK
import Sound.JACK.Exception
import System.Posix.Signals
import System.Process
import WithCli
import Control.Monad.Trans.Class (lift)

data ProcessPool = ProcessPool {
  spawn :: String -> [String] -> IO (),
  exit :: IO (),
  waitUntilExit :: IO ()
}

setupProcessPool :: IO ProcessPool
setupProcessPool = do
  children <- newMVar []
  waiter <- newEmptyMVar
  let terminateChildren = do
        modifyMVar_ children $ \ children -> do
          forM_ children $ \ (name, child) -> do
            putStrLn ("terminating: " ++ name)
            terminateProcess child
            putStrLn ("waiting for: " ++ name)
            _ <- waitForProcess child
            putStrLn ("done waiting for: " ++ name)
          return []
        putMVar waiter ()
  _ <- installHandler sigINT (CatchOnce terminateChildren) Nothing
  return $ ProcessPool {
    spawn = \ command args -> do
      (_, _, _, handle) <- createProcess (proc command args)
      modifyMVar_ children $ \ children -> return ((command, handle) : children)
      _ <- forkIO $ do
        _ <- waitForProcess handle
        putStrLn (command ++ " is done")
        terminateChildren
      return (),
    exit = terminateChildren,
    waitUntilExit = do
      readMVar waiter
  }

data Args
  = Args {
    selfCheck :: Bool
  }
  deriving (Show, Generic, HasArguments)

main :: IO ()
main = withCli $ \ args -> do
  if selfCheck args
    then putStrLn "checked!"
    else do
      pool <- setupProcessPool
      activateMonitor
      startJack pool
      spawn pool "a2jmidid" ["-e"]
      spawn pool "touchscreen-instrument" []
      spawn pool "guitarix" []
      wait 5
      connectPorts pool
      waitUntilExit pool

activateMonitor :: IO ()
activateMonitor = do
  cmd_ "xrandr --output eDP-1 --mode 2560x1440 --pos 0x0 --rotate normal --output DP-1 --off --output HDMI-1 --primary --mode 1920x1080 --pos 2560x360 --rotate normal --output DP-2 --off"

startJack :: ProcessPool -> IO ()
startJack pool = do
  spawn pool "jackd" $ words "--sync --realtime -d alsa --rate 48000 --period 256"
  putStrLn "waiting..."
  cmd_ "jack_wait -w"
  putStrLn "done!"
  wait 0.1

connectPorts :: ProcessPool -> IO ()
connectPorts pool = do
  _ <- forkIO $ do
    result <- runExceptionalT $
      withClientDefault "setup-touchscreen-instrument" $ \ client -> lift $ do
        makeConnections client
        let loop :: [String] -> IO ()
            loop previousPorts = do
              ports <- getPorts client
              when (previousPorts /= ports) $ do
                print "port change detected"
                makeConnections client
              wait 1
              loop ports
        loop =<< getPorts client
    case result of
      Success () -> return ()
      Exception (e :: All) -> do
        putStrLn $ toStringWithHead e
        exit pool
  return ()

makeConnections :: Client -> IO ()
makeConnections client = do
  let midiControllerPort port =
        "a2j:WORLDE easy control [" `isPrefixOf` port &&
        "] (capture): WORLDE easy control MIDI 1" `isSuffixOf` port
      expressionPedalPort port =
        "a2j:beat bars adapter [" `isPrefixOf` port &&
        "] (capture): beat bars adapter MIDI 1" `isSuffixOf` port
      connections =
        ((== "touchscreen-instrument:left-output"), "gx_head_amp:in_0") :
        (midiControllerPort, "touchscreen-instrument:controller") :
        (expressionPedalPort, "touchscreen-instrument:controller") :
        []
  forM_ connections $ \ (from, to) -> do
    tryConnect client from to

tryConnect :: Client -> (String -> Bool) -> String -> IO ()
tryConnect client from to = do
  ports <- getPorts client
  case filter from ports of
    [from] -> do
      Exit _ <- cmd "jack_connect" [from, to]
      return ()
    _ -> return ()

wait :: Double -> IO ()
wait seconds = threadDelay $ round (seconds * 1000000)
